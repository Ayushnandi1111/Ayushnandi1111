<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polygon Evolution Animation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
        }
        
        .container {
            position: relative;
            text-align: center;
        }
        
        canvas {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 255, 0.5);
            background: rgba(0, 10, 30, 0.7);
        }
        
        .info {
            color: white;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 20, 50, 0.7);
            border-radius: 10px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        
        h1 {
            color: #4cc9f0;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(76, 201, 240, 0.7);
        }
        
        p {
            line-height: 1.6;
            color: #a9d6e5;
        }
        
        .stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            font-weight: bold;
        }
        
        .stat-item {
            background: rgba(30, 60, 100, 0.8);
            padding: 8px 15px;
            border-radius: 20px;
            color: #4cc9f0;
        }
        
        @media (max-width: 600px) {
            .stats {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="animationCanvas" width="700" height="700"></canvas>
        <div class="info">
            <h1>Polygon Evolution</h1>
            <p>Watch as the ball collides with the polygon walls. Each collision increases the ball's speed and adds a side to the shape!</p>
            <div class="stats">
                <div class="stat-item">Sides: <span id="sideCount">3</span></div>
                <div class="stat-item">Speed: <span id="speedDisplay">1.0</span>x</div>
                <div class="stat-item">Collisions: <span id="collisionCount">0</span></div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('animationCanvas');
            const ctx = canvas.getContext('2d');
            const sideCountElement = document.getElementById('sideCount');
            const speedDisplayElement = document.getElementById('speedDisplay');
            const collisionCountElement = document.getElementById('collisionCount');
            
            // Canvas dimensions
            const width = canvas.width;
            const height = canvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Animation parameters
            const apothem = 200; // Fixed distance from center to sides
            let sides = 3; // Start with triangle
            let collisionCount = 0;
            let speedMultiplier = 1.0;
            
            // Ball properties
            const ball = {
                x: centerX,
                y: centerY,
                radius: 12,
                dx: 2,
                dy: 2,
                color: '#ff6b6b'
            };
            
            // Generate vertices for a regular polygon
            function generatePolygonVertices(sides) {
                const radius = apothem / Math.cos(Math.PI / sides);
                const vertices = [];
                const angleStep = (Math.PI * 2) / sides;
                
                for (let i = 0; i < sides; i++) {
                    const angle = i * angleStep - Math.PI / 2;
                    vertices.push({
                        x: centerX + radius * Math.cos(angle),
                        y: centerY + radius * Math.sin(angle)
                    });
                }
                return vertices;
            }
            
            // Calculate closest point on a line segment to a point
            function closestPointOnSegment(point, segA, segB) {
                const dx = segB.x - segA.x;
                const dy = segB.y - segA.y;
                const l2 = dx * dx + dy * dy;
                
                if (l2 === 0) return segA;
                
                let t = ((point.x - segA.x) * dx + (point.y - segA.y) * dy) / l2;
                t = Math.max(0, Math.min(1, t));
                
                return {
                    x: segA.x + t * dx,
                    y: segA.y + t * dy
                };
            }
            
            // Calculate distance between two points
            function distance(p1, p2) {
                return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
            }
            
            // Draw polygon
            function drawPolygon(vertices) {
                ctx.beginPath();
                ctx.moveTo(vertices[0].x, vertices[0].y);
                
                for (let i = 1; i < vertices.length; i++) {
                    ctx.lineTo(vertices[i].x, vertices[i].y);
                }
                
                ctx.closePath();
                ctx.strokeStyle = `hsl(${(sides * 30) % 360}, 80%, 60%)`;
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            
            // Draw ball
            function drawBall() {
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fillStyle = ball.color;
                ctx.fill();
                
                // Add shine effect
                ctx.beginPath();
                ctx.arc(ball.x - ball.radius/3, ball.y - ball.radius/3, ball.radius/3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.fill();
            }
            
            // Animate particles on collision
            function createCollisionParticles(x, y, count = 15) {
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1 + Math.random() * 3;
                    const size = 2 + Math.random() * 3;
                    const lifetime = 20 + Math.random() * 30;
                    
                    collisionParticles.push({
                        x, y,
                        dx: Math.cos(angle) * speed,
                        dy: Math.sin(angle) * speed,
                        radius: size,
                        color: `hsl(${(sides * 30) % 360}, 80%, 60%)`,
                        life: lifetime,
                        maxLife: lifetime
                    });
                }
            }
            
            // Collision particles
            const collisionParticles = [];
            
            function updateParticles() {
                for (let i = collisionParticles.length - 1; i >= 0; i--) {
                    const p = collisionParticles[i];
                    
                    // Move particle
                    p.x += p.dx;
                    p.y += p.dy;
                    
                    // Fade out
                    p.life--;
                    const opacity = p.life / p.maxLife;
                    
                    // Draw particle
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius * opacity, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.fill();
                    
                    // Remove dead particles
                    if (p.life <= 0) {
                        collisionParticles.splice(i, 1);
                    }
                }
            }
            
            // Main animation loop
            function animate() {
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Draw background grid
                drawBackground();
                
                // Generate polygon vertices based on current sides
                const vertices = generatePolygonVertices(sides);
                
                // Draw polygon
                drawPolygon(vertices);
                
                // Move ball
                ball.x += ball.dx;
                ball.y += ball.dy;
                
                // Check for collisions with polygon sides
                let collisionDetected = false;
                let minDistance = Infinity;
                let closestSide = null;
                let closestPoint = null;
                
                for (let i = 0; i < sides; i++) {
                    const A = vertices[i];
                    const B = vertices[(i + 1) % sides];
                    
                    // Find closest point on segment to ball center
                    const point = closestPointOnSegment(
                        {x: ball.x, y: ball.y},
                        A,
                        B
                    );
                    
                    const dist = distance({x: ball.x, y: ball.y}, point);
                    
                    if (dist < ball.radius && dist < minDistance) {
                        minDistance = dist;
                        closestSide = { A, B };
                        closestPoint = point;
                        collisionDetected = true;
                    }
                }
                
                // Handle collision if detected
                if (collisionDetected) {
                    const A = closestSide.A;
                    const B = closestSide.B;
                    
                    // Calculate midpoint of the side
                    const mid = {
                        x: (A.x + B.x) / 2,
                        y: (A.y + B.y) / 2
                    };
                    
                    // Calculate outward normal (from center to midpoint)
                    const normal = {
                        x: mid.x - centerX,
                        y: mid.y - centerY
                    };
                    
                    // Normalize the normal vector
                    const normLen = Math.sqrt(normal.x ** 2 + normal.y ** 2);
                    normal.x /= normLen;
                    normal.y /= normLen;
                    
                    // Reflect velocity vector
                    const dotProduct = ball.dx * normal.x + ball.dy * normal.y;
                    ball.dx -= 2 * dotProduct * normal.x;
                    ball.dy -= 2 * dotProduct * normal.y;
                    
                    // Increase speed
                    const speedBoost = 1.15;
                    ball.dx *= speedBoost;
                    ball.dy *= speedBoost;
                    speedMultiplier *= speedBoost;
                    
                    // Create particles at collision point
                    createCollisionParticles(closestPoint.x, closestPoint.y);
                    
                    // Push ball out of collision
                    const pushDistance = ball.radius - minDistance + 1;
                    ball.x += normal.x * pushDistance;
                    ball.y += normal.y * pushDistance;
                    
                    // Increase polygon sides
                    sides++;
                    collisionCount++;
                    
                    // Update stats display
                    sideCountElement.textContent = sides;
                    speedDisplayElement.textContent = speedMultiplier.toFixed(1);
                    collisionCountElement.textContent = collisionCount;
                    
                    // Change ball color gradually
                    const hue = (sides * 25) % 360;
                    ball.color = `hsl(${hue}, 80%, 60%)`;
                }
                
                // Ensure ball stays within canvas bounds
                if (ball.x - ball.radius < 0 || ball.x + ball.radius > width) {
                    ball.dx *= -1;
                    ball.x = Math.max(ball.radius, Math.min(width - ball.radius, ball.x));
                }
                
                if (ball.y - ball.radius < 0 || ball.y + ball.radius > height) {
                    ball.dy *= -1;
                    ball.y = Math.max(ball.radius, Math.min(height - ball.radius, ball.y));
                }
                
                // Update and draw particles
                updateParticles();
                
                // Draw ball
                drawBall();
                
                // Limit max sides to prevent performance issues
                if (sides > 30) {
                    sides = 30;
                }
                
                requestAnimationFrame(animate);
            }
            
            // Draw background grid
            function drawBackground() {
                ctx.strokeStyle = 'rgba(40, 80, 120, 0.3)';
                ctx.lineWidth = 1;
                
                // Vertical lines
                for (let x = 0; x <= width; x += 30) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }
                
                // Horizontal lines
                for (let y = 0; y <= height; y += 30) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
                
                // Center point
                ctx.beginPath();
                ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(76, 201, 240, 0.5)';
                ctx.fill();
            }
            
            // Start animation
            animate();
        });
    </script>
</body>
</html>